/*
* Copyright (c) 2011 Joshua Arnold
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*/

package lljvm.runtime;

import java.io.Closeable;

/**
 * Defines the runtime context for an LLJVM execution instance. <h3>Modules</h3>
 * <p>
 * LLJVM functions are contained in "modules", each consisting of a java class or interface.
 * In a given runtime context, each module is associated with a single instance which is of any type 
 * assignment compatible with the module's class. LLJVM translates invocation of the module's functions 
 * to invocation of corresponding methods on the module instance.
 * </p>
 * <p>
 * Any non-primitive, non-array {@link Class} may serve as a module class. In pure LLJVM code, the
 * modules classes will are generated by LLJVM. But arbitrary classes or interfaces may be used to
 * link LLJVM code to other JVM languages. It is also possible to subclass LLJVM generated classes and
 * override selected methods using other JVM languages.
 * </p>
 * <p>
 * Module instances <em>may</em> implement the {@link Module} interface, in which case the lifecycle
 * methods defined on that interface will be automatically invoked.
 * </p>
 * 
 * @author Joshua Arnold
 */
public interface Context extends Closeable {

    /**
     * Returns the instance associated with the specified module. 
     * <p>If the instance does not yet
     * exist, the context <em>may</em> attempt to construct one.</p>
     * 
     * @param <T>
     *            the module type
     * @param clazz
     *            the class that defines the module
     * @return the module instance.
     * @throws IllegalStateException
     *             if the context is closed.
     */
    <T> T getModule(Class<T> clazz);

    /**
     * Returns the instance associated with the specified module, but only if the instance already
     * exists.
     * <p>
     * Unlike {@link #getModule(Class)}, this method is guaranteed to never cause a module instance
     * to be created.
     * </p>
     * 
     * @param <T>
     *            the module type
     * @param clazz
     *            the class that defines the module
     * @return the module instance.
     */
    <T> T getOptionalModule(Class<T> clazz);

    /**
     * Shuts down the context.
     * <p>
     * This method informs the context that is no longer being used and that it may release any
     * expensive resources. Note that this method does not forcibly stop modules associated with
     * this Context from running. The behavior of invoking module instances after their
     * corresponding context is closed is undefined.
     * </p>
     */
    void close();

}
