#!/usr/bin/python
# Copyright (c) 2009 David Roberts <d@vidr.cc>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

import os
import sys
import subprocess

# LLJVM root directory
lljvm_dir = os.path.abspath(os.path.dirname(sys.argv.pop(0)))

# dummy file
# TODO: make system-independent
fnull = open('/dev/null', 'w')

def command_exists(name):
    """Returns true iff a command with the given name exists."""
    # TODO: make system-independent
    return subprocess.call(['which', name], stdout=fnull) == 0

# C Compiler
if command_exists('llvm-gcc'): cc = 'llvm-gcc'
elif command_exists('clang'):  cc = 'clang'
else:                          cc = None

# default flags to pass to the compiler
default_cflags = (
    '-D__LLJVM__',
    '-I' + os.path.join(lljvm_dir, 'include', 'lljvm'),
    '-I' + os.path.join(lljvm_dir, 'include', 'newlib'),
    '-fno-builtin-rintl', '-fno-builtin-lrintl', '-fno-builtin-llrintl',
)

# command for executing the LLJVM linker
lljvm_ld_cmd = ('java', '-jar', os.path.join(lljvm_dir, 'lljvm.jar'), 'ld')

# default java classes to link against
default_java_libs = (
    'lljvm.lib.c',
    'lljvm.runtime.System',
    'lljvm.runtime.IO',
    'lljvm.runtime.Posix',
    'lljvm.runtime.Jump',
    'java.lang.Math',
    'lljvm.runtime.Math',
)

# (partial) list of flags that take an argument
# TODO: complete list
takes_argument = ('-MF', '-MT', '-MQ', '-include')

# (partial) list of flags not recognised by llvm-ld
# TODO: need a better way of filtering out invalid flags
invalid_ld_flags = ('-pthread', '-shared', '-nostdlib', '-lgcc',
                    '-static-libgcc', '-link', '-MF', '-MT', '-MQ', '-include')

# template for the launcher script
script_template = \
    '#!/bin/sh\n' \
    'export CLASSPATH="`dirname "$0"`:' \
    + os.path.join(lljvm_dir, 'lljvm.jar') + \
    ':${CLASSPATH-.}"\n' \
    'exec java %s "$0" ${1+"$@"}\n'

def die(message, status=1):
    """Print the given message to stderr and terminate with the given
    status."""
    sys.stderr.write(message)
    sys.exit(status)

def element_startswith(l, s):
    """Returns true iff any of the elements in the given list begin with the
    given string."""
    return reduce(lambda x, y: x or y.startswith(s), l, False)

def startswith_element(s, l):
    """Returns true iff the given string begins with any of the elements in the
    given list."""
    return reduce(lambda x, y: x or s.startswith(y), l, False)

def remove_filext(s):
    """Remove the file extension from the given string."""
    dot = s.rfind('.')
    if dot == -1: return s
    return s[:dot]

def call_e(*popenargs, **kwargs):
    """Call the given command, exiting if it has a non-zero return code."""
    p = subprocess.Popen(*popenargs, **kwargs)
    if p.wait() != 0: sys.exit(p.returncode)

def parse_argv(separate_sources=True):
    """Parse sys.argv, returning the flags and the output file, and separating
    the sources from the flags if required."""
    flags = []
    output = 'a.out'
    if separate_sources: srcs = []

    while sys.argv:
        arg = sys.argv.pop(0)
        if separate_sources and arg[0] != '-':
            srcs.append(arg)
        elif arg == '-o':
            output = sys.argv.pop(0)
        elif arg in takes_argument:
            flags.append(arg)
            flags.append(sys.argv.pop(0))
        else:
            flags.append(arg)
    
    if separate_sources:
        return flags, output, srcs
    return flags, output

def filter_flags_fn(flags, fn):
    """Filter the given list of flags according to the given function,
    respecting takes_argument."""
    newflags = []
    oldflags = list(flags)
    while oldflags:
        flag = oldflags.pop(0)
        arg = oldflags.pop(0) if flag in takes_argument else None
        if fn(flag):
            newflags.append(flag)
            if arg: newflags.append(arg)
    return newflags

def filter_flags(flags, invalid_flags=(), startswith=None, notstartswith=None):
    """Filter invalid flags out of the given list. If startswith is specified,
    then only flags that begin with an element of the given list will be
    retained. Otherwise, if notstartswith is specified, any flag that begins
    with an element of the given list will be removed."""
    if startswith and notstartswith:
        raise TypeError("cannot specify both startswith and notstartswith")
    flags = list(flags)
    if invalid_flags: flags = filter_flags_fn(flags,
            lambda x: x not in invalid_flags)
    if startswith: flags = filter_flags_fn(flags,
            lambda x: startswith_element(x, startswith))
    if notstartswith: flags = filter_flags_fn(flags,
            lambda x: not startswith_element(x, notstartswith))
    return flags

def filter_cc_flags(flags):
    """Remove arguments from the given list that should be passed to the
    backend instead of cc, and return the new list of arguments."""
    return filter_flags(flags, notstartswith=('-classname', '-g'))

def filter_ld_flags(flags):
    """Remove arguments not recognised by llvm-ld from the given list, and
    return the new list of arguments."""
    return filter_flags(flags, invalid_ld_flags,
                        notstartswith=('-f', '-g', '-D', '-O', '-W'))

def filter_backend_flags(flags):
    """Return a list of only those flags accepted by lljvm-backend."""
    return filter_flags(flags, startswith=('-classname', '-g'))

def bc2class(output, flags):
    """Generate {output}.class from {output}.bc and unlink {output}.bc"""
    flags = filter_backend_flags(flags)
    output_j = open(output + '.j', 'w')
    backend_process = subprocess.Popen(
        [os.path.join(lljvm_dir, 'lljvm-backend'), output + '.bc'] + flags,
        stdout=subprocess.PIPE)
    linker_returncode = subprocess.Popen(
        lljvm_ld_cmd + default_java_libs,
        stdin=backend_process.stdout, stdout=output_j).wait()
    output_j.close()
    
    if linker_returncode != 0:
        backend_process.kill()
        sys.exit(linker_returncode)
    if backend_process.wait() != 0:
        sys.exit(backend_process.returncode)
    os.unlink(output + '.bc')
    
    outpath = os.path.dirname(output) or '.'
    call_e(['java', 'jasmin.Main', '-d', outpath, output + '.j'], stdout=fnull)
    if '-g3' not in flags:
        os.unlink(output + '.j')
    
    script = open(output, 'w')
    script.write(script_template % os.path.basename(output).replace('.', '_'))
    script.close()
    os.chmod(output, 0755)

def link(flags, output):
    """Call llvm-ld with the given flags, and call bc2class on the output."""
    call_e(['llvm-ld', '--disable-opt', '-o', output] + filter_ld_flags(flags))
    os.unlink(output)
    bc2class(output, flags)

def main():
    if not cc: die("Error: either llvm-gcc or clang must be installed")
    if '-link' in sys.argv:
        link(*parse_argv(False)); return
    if '-c' in sys.argv or '-E' in sys.argv:
        flags = filter_cc_flags(sys.argv)
        call_e([cc, '-emit-llvm'] + list(default_cflags) + flags); return
    flags, output, srcs = parse_argv()
    objs = map(lambda src: remove_filext(os.path.basename(src)) + '.o', srcs)
    call_e([cc, '-emit-llvm', '-c'] + list(default_cflags)
           + filter_cc_flags(flags) + srcs)
    link(flags + objs, output)
    map(os.unlink, objs)
if __name__ == '__main__': main()
